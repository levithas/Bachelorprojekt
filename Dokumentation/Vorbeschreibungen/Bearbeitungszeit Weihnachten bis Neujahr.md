# Intent Manager

Der Intent Manager dient dazu Profile für externe Anwendungen anzulegen, die auf die Datenbank von AiXDroid zugreifen können sollen. Es können Berechtigungen festgelegt werden und der Anwendung selbst ein Name gegeben werden. Sobald das Profil angelegt ist kann die externe App einen Intent senden, der entweder Daten beinhaltet die in die Datenbank eingegeben werden sollen oder Daten zum auslesen einer bestimmten Datenreihe enthalten. Wenn die App die nötigen Zugriffsrechte hat, werden die angeforderten Daten anschließend in einem Intent an die externe App gesendet.

Die Zugriffsrechte sind durch das Interface \textit{ActionIntent} definiert. So können neue Zugriffsrechte einfach ergänzt werden ohne mit der übrigen Rechteverwaltung zu interferieren. Zur Zeit sind 2 Rechte implementiert: ReadDataExternalIntentAction und WriteDataExternalIntentAction.

Die \textbf{ReadDataExternalIntentAction} erwartet in den Extras des gesendeten Intent ein Bundle-Objekt mit 3 Einträgen. Der Eintrag "dataSeries" bezeichnet den Namen der Datenreihe, die gelesen werden soll als String. Der Eintrag "maxTime" ist ein Wert im Long-Format und gibt den höchsten Zeitstempel der auszulesenden Daten an. Der Eintrag "dataCount" ist ein Integer-Wert, welcher die Anzahl der zurückzugebenen Daten angibt. Es werden die maximale Zeit sowie die Anzahl der Daten als Parameter angefordert um, bei möglichen Zeitlücken die möglichkeit offen zu lassen alle vorhandenen Daten einfach zu erhalten. Wenn statt des dataCount die minTime angegeben würde, könnte man nie feststellen, wo sich der Wert mit dem niedrigsten Zeitstempel befindet. Man müsste alle Werte bis hin zum Minimum des Zeitstempels (1. Januar 1970) abrufen, was zu einer enormen Datenmenge führen könnte. Die Filterung der Daten wird über ein SQL-Statement vorgenommen. So wird der Aufruf selbst sowie die Filterung durch die Datenbank selbst abgehandelt.

Die \textbf{WriteDataExternalIntentAction} erwartet in den Extras des gesendeten Intent ein Bundle-Objekt mit 3 Einträgen. Der Eintrag "dataSeries" gibt wieder den Namen der Datenreihe an. Sollte sich keine solche Datenreihe in der Datenbank befinden wird diese neu angelegt. Der nächste Eintrag "timeValueArray" stellt ein Array von Zeitpunkten im Long-Format dar. Hier werden alle Zeitpunkte, die in die Datenreihe eingegeben werden sollen aufgelistet. Der letzte Eintrag "dataValueArray" beinhaltet die Werte zu den zuvor gegebenen Zeitpunkten. Es handelt sich hierbei um Float-Werte. Die Datenwerte in diesem Array werden zu den Zeitwerten in genau der Reihenfolge in der sie in den Arrays stehen gemapped. Sollte die Datenreihe vorher bereits existiert haben und die Zeitstempel bereits vorhanden sein, so werden die alten Werte von den neuen überschrieben.

#### External Intent Service

Um die konfigurierten Intents zu empfangen läuft in der AiXDroid-Anwendung ein Foreground-Service. Dieser geht die Liste der Profile im Intent-Manager durch, sobald eine Änderung in der Datenbank-Tabelle stattfindet. Es wird für jedes Profil ein ExternalIntentReceiver Objekt erstellt und registriert. Diese Klasse implementiert den von Android bereitgestellten BroadcastReceiver. Diese sorgen dafür, dass ankommende Intents verarbeitet werden. Die ExternalIntentReceiver erweitern die Funktion des BroadcastReceivers um die angegebene IntentAction in Form eines Strategy-Patterns. Innerhalb der IntentAction-Implementierungen werden über Dependency Injection die verwendeten UseCases eingefügt.

# Data Manager

Über den Data Manager werden die Datenreihen, die manuell importiert oder von anderen Apps an die AiXDroid-App gesendet wurden verwaltet. Die Daten gliedern sich hier in Datenpunkte, Datenreihen und Datensätze. Datenpunkte beschreiben die einfachste Form eines Datums. Sie geben den Zeitpunkt in Form eines Zeitstempels (Unix-Timestamp) an, bei welchem der entsprechende Wert erfasst wurde. Der Wert selbst ist im Float-Format abgelegt. Datenpunkte selbst können nicht ohne eine zugewiesene Datenreihe existieren. Die Datenreihe hingegen kann aber ohne Datenpunkte bestehen. Hier werden Informationen wie, der eindeutige Name der Datenreihe, die Einheit, in welcher die Datenpunkte aufgenommen wurden und der Ursprung der Daten gespeichert. Außerdem enthält die Datenreihe Informationen über die Menge der zugewiesenen Datenpunkte, wie die Anzahl aller Punkte, der Zeitwert des kleinsten Zeitstempels sowie des höchsten Zeitstempels. Eine Datenreihe alleine reicht noch nicht aus, um in einem Modell verwertet zu werden. Hierzu wird ein Datensatz angelegt. Ein Datensatz beinhaltet mindestens eine Datenreihe, hat einen Namen und kann Informationen zu einem zugewiesenen KI-Modell beinhalten. Eine Datenreihe ist hierbei nicht an einen einzigen Datensatz gebunden. Es können auch Datenreihen in mehreren Datensätzen eingebunden sein. Hierbei werden keine Kopien der Reihen erstellt sondern es wird auf Referenzen verwiesen. Die Zuweisung eines KI-Modells geschieht über den Datensatz selbst. Es wird ein passendes Modell ausgewählt und die Zuweisung der Datenreihen zu den Input-Tensoren des Modelles definiert. Es können nur Modelle gewählt werden, die maximal so viele Input-Tensoren haben, wie in dem Datensatz Datenreihen vorhanden sind. Zuletzt wird der Name und die Einheit des Outputs des Modells angegeben. Eine neue Datenreihe wird erstellt und die Inference gestartet. Wenn das Feld "Auto-Inference" aktiviert wurde, startet die App automatisch eine erneute Inference, sobald eine Änderung an den Datenreihen im Datensatz festgestellt wurde. Hierbei werden ausschließlich neu hinzugefügte Daten verarbeitet um Ressourcen zu sparen. Es kann manuell eine vollständige Neuberechnung gestartet werden, wenn dies nötig ist (z.B. bei Änderungen von alten Datenpunkten). Die berechneten Datenreihen tragen als Ursprung die Bezeichung "Prediction" um zu zeigen, dass diese Werte errechnet wurden. Datensätze können auch berechnete Datenreihen beinhalten. Der Datensatz könnte beispielsweise errechnete Schlaflabels und gemessene Puls-Werte als Input-Werte für ein anderes Modell verwenden um hieraus wiederum einen Erholungsindex zu berechnen. Durch die Auto-Inference würden sich beide Datensätze hintereinander automatisch aktualisieren.


### Model View ViewModel (MVVM)

\subsection{Model View Viewmodel (MVVM)}
Nach \cite{archiveddocsMVVMPattern2012} ist \textit{Model View Viewmodel} (MVVM) ein Architekturmodell, das auf dem bekannten \textit{Model View Controller} (MVC) -Modell aufbaut. Es hilft dabei das Prinzip der Trennung von Verantwortlichkeiten (Separation of Concerns) zu beachten, durch eine klare Trennung zwischen Anwendungslogik und Benutzeroberfläche. Es besteht aus 3 Komponenten.

\subsubsection{Model}
Das Model in der  MVVM-Architektur enthält die Strukturen und Datenobjekte zusammen mit der Validierungslogik für diese Objekte. Diese Objekte stellen die Repositories, die UseCases, Datentranferobjekte (DTOs) und Entitätenmodelle dar.

\subsubsection{View}
Die View ist verantwortlich für die Struktur, das Layout und die Darstellung dessen, was der Anwender auf dem Bildschirm sieht. Sie stellt demnach die Benutzeroberfläche dar. Die View enthält keine Geschäftslogik. Das heißt, sie ist unabhängig von der Implementierung der eigentlichen Aufgaben der Anwendung. Über ein Viewmodel sendet die View Aktionen an die Geschäftslogik und erhält Daten und Zustände für ihre Anzeigeelemente. 

\subsubsection{Viewmodel}
Das Viewmodel dient als Zwischenhändler von View und Model und steuert die Logik der View. Das Viewmodel interagiert mit dem Modell, indem es Methoden der Modellklassen aufruft. Es stellt dann die Daten aus dem Modell in einer Form bereit, die die View einfacher verwenden kann. Es ruft also Daten aus dem Modell ab und macht sie für die Benutzeroberfläche verfügbar, wobei es die Daten gegebenenfalls umformatiert, um sie handhabbarer zu machen. Zudem implementiert das Viewmodel Befehle, die in der View ausgelöst werden. Ein Beispiel dafür wäre, wenn ein Benutzer in der Benutzeroberfläche auf einen Button klickt. Diese Aktion würde dann einen Befehl im Viewmodel auslösen , welcher wiederum Verarbeitungen in den Modellen auslöst. Das ViewModel kann für Zustandsänderungen verantwortlich sein, die ein Anzeigeelement in der Ansicht beeinflussen. So können zum Beispiel die Elemente einer Liste automatisch aktualisiert werden und vom Viewmodel der View bereitgestellt werden, ohne dass eine weitere Aktion der View notwendig wird.




### 